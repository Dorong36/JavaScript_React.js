<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <!-- 
        🌟🌟🌟 훅 (Hook) 🌟🌟🌟
        ** Hook 이란?
        - 기존 함수 컴포넌트는 별도로 state 정의나 특정 코드가 생명주기에 맞춰 실행되도록 할 수 없었음
            => 훅(Hook)으로 기능 지원!!
        - 원래 존재하는 어떤 기능에 갈고리를 거는 것처럼 끼어 들어가 같이 수행되는 것
            => 리액트 state와 생명주기 기능에 갈고리를 걸어 원하는 시점에 특정 함수 실행
        - 훅의 이름은 모두 use로 시작!!

        ** useState
        - state를 사용하기 위한 훅
        - 사용법
            import React, {useState} from "react";
            const [변수명, set함수형] = useState(초깃값);
        - 클래스 컴포넌트와 달리 변수 각각에 대한 set 함수가 따로 존재!!

        ** useEffect
        - 사이드 이펙트(side effect)를 수행하기 위한 훅
            => 다른 컴포넌트에 영향을 미칠 수 있으며 렌더링 중에는 작업이 완료될 수 없는 작업
            => 렌더링이 끝난 이후 실행되어야 하는 작업들
            => ex) 서버에서 데이터를 받아오거나 수동으로 DOM을 변경하는 작업 등
        - componentDidMount(), componentUpdate(), componentWillUnmount() 기능 통합 제공
            => 생명주기 함수와 동일한 기능 수행
        - 사용법
            useEffect(이펙트 함수, 의존성 배열);
        * 실행
            - 기본적으로 처음 컴포넌트가 렌더링된 이후, 업데이트로 인한 재렌더링 이후 실행
                => 의존성 배열 안의 변수 중 하나라도 값이 변경되면 이펙트 함수 실행
            - 의존성 배열이 빈 배열([])이면 마운트, 언마운트시에 한 번씩만 실행 
            - 의존성 배열 생략 시 컴포넌트가 업데이트될 때마다 호출
        - useEffect에서 리턴하는 함수는 컴포넌트가 해제되기 직전 호출!!!
            => componentWillUnmount() 기능과 동일!!
        - useEffect() 훅은 하나의 컴포넌트에 여러 개를 사용할 수 있음

        ** useMemo
        - Memorized value를 리턴하는 훅
        - 파라미터 => Memorized value를 생성하는 create 함수, 의존성 배열
        - 의존성 배열 변수 변했을 경우에만 새로 create 함수 호출하여 결괏값 반환
        - 컴포넌트가 다시 렌더링 될 때마다 연산량이 높은 작업을 반복하는 것을 피할 수 있음
        - 사용법
            const memorizedValue = useMemo(
                () => {
                    return computeExpensiveValue(의존성 변수1, 의존선 변수2);
                },
                [의존성 변수1, 의존성 변수2]
            );
        - useMemo()로 전달된 함수는 렌더링이 일어나는 동안 실행
                => 사이드 이펙트 등 렌더링 동안 실행돼서는 안되는 작업 넣으면 안됨!!
        - 의존성 배열을 빈배열로 넣거나 비우면 useMemo()의 의미가 없어짐!!
                => 나중엔 컴파일러가 개선되어 자동 생성 해주기도 함
                => eslint-plugin-react-hooks패키지 사용시  의존성 배열 입력에 도움

        ** useCallback
        - useMemo()훅과 유사한 역할, but 값이 아닌 함수를 반환한다는 차이점!!
        - useMemo()와 동일하게 함수(<= 이 함수를 '콜백'이라고 지칭)와 의존성 배열 파라미터
        - 의존성 배열 값 변경 시 콜백함수 반환
        - 사용법
            const memorizedCallback = useCallback(
                () => {
                    doSomething(의존성 변수1, 의존성 변수2);
                },
                [의존성 변수1, 의존성 변수2]
            );
        - 일반적으로 컴포넌트 내에 함수를 정의했을 때 렌더링 때마다 함수가 새로 정의되는 불필요한 작업 제거
            +) 만약 컴포넌트 내 정의 함수가 자식 컴포넌트에 props로 넘겨 사용하면 그 자식까지 매번 렌더링 되는 참사 발생
                
        ** useRef
        - 레퍼런스(특정 컴포넌트에 접근할 수 있는 객체)를 사용하기 우한 훅
        - current 속성을 가진 레퍼런스 객체를 반환
        - 사용법
            const refContainer = useRef(초깃값);
        - 초깃값으로 최기화된 current값을 지는 레퍼런스 객체 반환
        - 반환된 레퍼런스 객체는 컴포넌트 라이프타임 전체에 걸쳐 유지
        - 내부 데이터(current)가 변경되어도 별도로 재렌더링을 일으키지 않음

        ** 훅의 규칙
        1. 훅은 무조건 최상위 레벨에서만 호출해야 한다
            - 최상위 레벨 == 리액트 함수 컴포넌트의 최상위 레벨
            - 반복문이나 조건문 또는 중첩된 함수 안에서 훅을 호출하면 안됨
            - 조건에 따른 변동 등 없이 매번 렌더링 때마다 같은 순서로 훅이 호출되어야 함
        2. 리액트 함수 컴포넌트에서만 훅을 호출해야 한다
            - 일반적 자바스크립트 함수에서 훅을 호출하면 안됨
            - 훅은 리액트 함수 컴포넌트 or 직접 만든 커스텀 훅에서만 호출 가능

        ** 나만의 훅 만들기 (Custom Hook)
        - 이름은 반드시 use로 시작, 내부에서 다른 훅을 호출하는 하나의 자바스크립트 함수
        - 훅 사용에 있어서 중복되는 코드를 줄이기 위함
        - 두 개의 JS 함수에서 하나의 로직을 공유하도록 하고 싶을 때 새로운 함수를 만드는 것과 동일
        - 컴포넌트 내부에서와 마찬가지로 다른 훅을 호출하는 것은 반드시 커스텀 훅의 최상위 레벨에서만 가능
            +) 같은 커스텀 훅을 사용하는 두 개의 컴포넌트는 state를 공유할까?
                => No!! 모든 state와 effects는 전부 분리되어 있음

        


     -->
</body>
</html>